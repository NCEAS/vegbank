Option Compare Database
Option Explicit

Public Function Get_PlantName_ID(plantName As String, Optional blnAddIfNotFound As Boolean) As Long
  Dim rstCurr As New ADODB.Recordset
  rstCurr.Open "SELECT plantName_ID FROM plantNAme WHERE plantName = " & SQLizeTxt(plantName, "'") & ";", CurrentProject.Connection _
     , adOpenForwardOnly, adLockReadOnly, adCmdText
  If rstCurr.EOF Then
    ''no plantName that matches
     If blnAddIfNotFound Then 'add this name and try to find reference in Z_B
      Dim lngRef As Long, strTempFind As String
      lngRef = getPlantReferenceOfNm(plantName)
      Get_PlantName_ID = add_plantName_to_VB(plantName, lngRef)
    Else
      Get_PlantName_ID = -1
    End If
  Else
    Get_PlantName_ID = rstCurr!PLANTNAME_ID
  End If
  rstCurr.Close
End Function

Public Function get_plantName_fromID(lngPK As Long) As String
  Dim rstCurr As New ADODB.Recordset
  rstCurr.Open "SELECT plantName FROM plantNAme WHERE plantName_ID = " & lngPK & ";", CurrentProject.Connection _
     , adOpenForwardOnly, adLockReadOnly, adCmdText
  If rstCurr.EOF Then
    ''no plantName that matches
    get_plantName_fromID = ""
  Else
    get_plantName_fromID = rstCurr!plantName
  End If
  rstCurr.Close
End Function

Function fjdafjajf()
  Dim intRet As Integer, colConcepts As New Collection
  Debug.Print get_PlantConcept_ID(Get_PlantName_ID("NewThang"), _
         Now(), "", 5, "", intRet, True, colConcepts)
  Debug.Print "---:" & intRet
  Dim intemp As Integer
  For intemp = 1 To colConcepts.Count
    Debug.Print colConcepts(intemp)
  Next
End Function



Public Function get_PlantConcept_ID(lngPlantNameID As Long, datDate As Date, strPlStatus As String, _
      lngPlantParty As Long, strClassSys As String, intReturnAlso As Integer, _
      blnGetMult As Boolean, Optional colConcepts As Collection) As Long
  '' function gets a plantConcept_ID, based on plantUsage table
   ''strClassSystem is optional - pass "" to ignore
'Debug.Print "get_PlantConcept_ID >> name:" & lngPlantNameID & " ; party:" & lngPlantParty
   Dim rstConc As New ADODB.Recordset, strPlantName As String
   strPlantName = getvalFrmSQL("select plantName from plantNAme where plantName_ID=" & lngPlantNameID)
   ''open recordset that matches above criteria
   rstConc.Open "SELECT plantConcept_ID FROM plantUsage WHERE " _
      & " PlantName = " & SQLizeTxt(strPlantName) & " AND " _
      & " usageStart < #" & datDate & "# AND ((usageStop > #" & datDate & "#) or ((usageStop) is null)) " _
      & IIf((strPlStatus = ""), "", " AND plantNameStatus = " & SQLizeTxt(strPlStatus, "'") & " ") _
      & " AND Party_ID = " & lngPlantParty _
      & IIf(strClassSys = "", "", " AND classSystem = " & SQLizeTxt(strClassSys, "'") & " "), _
      CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText

   If rstConc.EOF Then
     intReturnAlso = 0 ''no concept matches above criteria
     get_PlantConcept_ID = -1 'don't return any concept
   Else
     ''return concept ID
     get_PlantConcept_ID = rstConc!PLANTCONCEPT_ID
     ''add to collection, if to return a collection
     If blnGetMult Then colConcepts.Add (rstConc!PLANTCONCEPT_ID)
     rstConc.MoveNext
     intReturnAlso = 1 ''concept returned, is the only one
     Do Until rstConc.EOF
       intReturnAlso = 2 '' ambiguous concept, ID returned, but other concepts exist that also match
       If blnGetMult Then  'store list of concepts in collection to pass back
         colConcepts.Add (rstConc!PLANTCONCEPT_ID)
       Else  ''exit function, b/c list of concepts not wanted
         Exit Function
       End If
       rstConc.MoveNext
     Loop
     
   End If
End Function

Function test12345774f4f4f4fggrew()
  Debug.Print InterpretPlName_PlConc("ACRU")
End Function
Public Function InterpretPlName_PlConc(strPlantName As String, Optional lngParty As Long, _
   Optional strNameFound As String, Optional lngIteration As Long, Optional strReturn As String, Optional blnCacheOK As Boolean) As Long
  ''function interprets a string expression, allegedly a plant name to a plant concept
    ''--BASED ON: 1) names in Z_VB_reconcile table _
                          (LoadvarName = plantName, VBTableName = plantConcept, VBFieldName = plantConcept_ID)
    ''            2a) plantname + reference combination in Z_USER_B_SpecList if found in plantConcept _
                       (this is the way new plants that are loaded are found again)
    ''            2aa) name matches valid concept accessionCode
    ''            2b) name listed in Z_USER_B_specList as plantCode --> then get concept from its plantName, _
                          which reruns this function with new strPlantName:
    ''            3) the priority order listed in Z_B_PriorityConceptLookup and criteria listed there _
                          (party, class system, etc)
    ''            ---If no unambiguous concept can be found, then user is prompted to decide, _
                          this result is stored in Z_VB_reconcile table
    ''-------------------------------------------------------------------------
    '' lngParty is returned by this funtion, too.
    ''-------------------------------------------
'Debug.Print "InterpretPlName_PlConc >> " & strPlantName
  strNameFound = strPlantName 'default found name unless recursed into new instance of this
Dim rstCurr As New ADODB.Recordset, cnnLoc As Connection, inttemp As Long
Set cnnLoc = CurrentProject.Connection
Dim intReturn As Integer ''gets type of concept that returns, ambiguous or not
  
If blnCacheOK Then
  'get from cache
  Dim strNumb As String
  strNumb = getvalFrmSQL("select plantConcept_ID from Z_b_VB_lookupNms where plantName=" & SQLizeTxt(strPlantName))
  If IsNumeric(strNumb) And strNumb <> "-1" And strNumb <> "0" And strNumb <> "" Then
    InterpretPlName_PlConc = strNumb
    Exit Function
  End If

End If
  
  '--look now in Z_VB_reconcile, where tables and fields are correct, as well as LoadVAlue = string we're looking for:
  rstCurr.Open "SELECT * FROM Z_VB_reconcile WHERE LoadVarName = ""plantName"" AND VBTableName = ""plantConcept""" _
      & " AND VBFieldName = ""plantConcept_ID""" _
      & " AND LoadVarValue = " & SQLizeTxt(strPlantName, "'") & ";", cnnLoc, adOpenForwardOnly, adLockReadOnly, adCmdText
    If Not (rstCurr.EOF) Then
       Debug.Print "VB_Reconcile had a value"
       ''got the concept from Z_VB_reconcile
       InterpretPlName_PlConc = rstCurr!VBFieldValue
       
       Exit Function
    Else  ''can't find the code for this plant name
    End If
  rstCurr.Close
  ''haven't found the concept in Z_VB_reconcile
  ''look in Z_USER_B_SpecList: but do not select any matches that are matched to itself
  rstCurr.Open "SELECT * FROM Z_USER_B_specList WHERE plantCode = " & SQLizeTxt(strPlantName, "'") & "  and plantName<>" & SQLizeTxt(strPlantName, "'") & " ; ", cnnLoc, adOpenForwardOnly, adLockReadOnly, adCmdText
  If Not (rstCurr.EOF) Then
   ''  Debug.Print "SPEC LIST got a code"
     ''FOUND CODE IN SPEC LIST -- look to see if it's a new user concept or not:
     With rstCurr
     If Not IsNull(!reference) Then  ''there is a reference, search for name + reference = concept
       Dim rstConc As New ADODB.Recordset
       ''check to see if concept is referred to explicitly:
       rstConc.Open "SELECT plantConcept_ID FROM plantConcept WHERE Reference_ID = " _
       & get_Ref(!reference) & " AND plantName = " _
       & SQLizeTxt(!plantName) & ";", CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
       If rstConc.EOF Then
         ''can't find it : continue with other attempts to figure this plant concept out below.
       Else
         ''did find exact concept: use it!
         InterpretPlName_PlConc = rstConc!PLANTCONCEPT_ID
       
         Exit Function
       End If
       rstConc.Close
     End If 'checking for reference
     
     ''call another instance of this function to get new name based on plantNAme, not plantCode (pointer)
       
       If IsNull(!plantName) Then
         'error with plantNAme, which should not be null : lookup code by skipping this part
         inttemp = -1
       Else
          strReturn = strReturn & IIf(strReturn <> "", "   -->   ", "") & strPlantName
          If lngIteration > 9 Then
            'too many iterations : reported as different error
          '  DoCmd.OpenForm "error_report", acNormal, , , , , strTrailOfNames
          '  msgBox "Your species list is too iterative.  Values in plantName are looked up again in a new row of the species list, if a match is found in plantCode.  This can lead to infinite loops.  For example: plantCode=""ACRU"", plantNAme=""Acer rubrum"" ; (new row) plantCode=""Acer rubrum"", plantName=""Acer""; (new row) plantCode=""Acer"", plantName=""ACRU""" _
               & "Your list of plants that has caused this error appears in the errorBox behind this window.  Please fix this loop and try matching plants again."
            inttemp = -3 'new code: invalid loop
            
          Else
            inttemp = InterpretPlName_PlConc(!plantName, , strNameFound, lngIteration + 1, strReturn)
          End If
       End If
     ''End If ''new concept or not
     End With
     
     If inttemp <> -1 Then
       ''got the concept from Z_USER_B's PK --> in Z_B_VBLookup
       InterpretPlName_PlConc = inttemp
       
       Exit Function
     End If
  Else  ''can't find the code for this plant name
  End If ''looking for the plantName as a plantCode in Z_UESR_B
  rstCurr.Close

  ''didn't find in Z_USER_B_SpecList
  '--now look at it as accessionCode?
   'check to see if name is valid accesionCode, if so, if matches extant plantConcept
     If accessionCodeValid(strPlantName) Then
          'have name that is a valid accessionCode
          'see if it matches plantConcept record
          inttemp = getPKfromAccessionCode(strPlantName, "plantConcept")
          If inttemp > 0 Then
            'great, we have the concept, as the name is an accessionCode!
            strReturn = "Name was accessionCode"
            InterpretPlName_PlConc = inttemp
            Exit Function
          End If
     End If

  '--look now in plantUsage, using criteria from Z_B_PriorityConceptLookup
  rstCurr.Open "SELECT * FROM Z_B_PriorityConceptLookup ORDER BY Priority;", _
      cnnLoc, adOpenForwardOnly, adLockReadOnly, adCmdText
  With rstCurr
  Do Until .EOF
     'loop thru priority ordered list of plant lookups

     inttemp = get_PlantConcept_ID(Get_PlantName_ID(strPlantName), Nz(!Date, Now()), Nz(!NameStatus, ""), _
         !PARTY_ID, Nz(!classSystem, ""), intReturn, False)
     If inttemp <> -1 Then
   ''     Debug.Print !party_ID & " had a concept"
        If intReturn = 2 Then
         ''ambiguous, return -2
         InterpretPlName_PlConc = -2
         strReturn = "Ambiguous name: " & strPlantName
         lngParty = !PARTY_ID
        Else
         'not ambiguous, return value
         InterpretPlName_PlConc = inttemp
         lngParty = !PARTY_ID
        End If
        Exit Function
     Else
       ''could not find name according to above criteria, try next list
       ''Debug.Print !party_ID & " had nothing matching"
     End If
  .MoveNext
  Loop
  End With
  ''if you got thru to here, then we can't find a concept with the name at all, that fits list
  InterpretPlName_PlConc = -1
End Function

''Public Function getPlantConceptIDfromZB_ID(lngPK As Long) As Long
  ''_DEFUNCT!--
''gets plantConcept_ID from Z_USER_B_specList's pk, looking in Z_B_VBLookup
''Dim rstCurr As New ADODB.Recordset
'rstCurr.Open "SELECT PLANTCONCEPT_ID FROM Z_B_VBLookup WHERE UserPlant_ID = " & lngPK, _
 '  CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
'If rstCurr.EOF Then
 ' 'can't find it
  'getPlantConceptIDfromZB_ID = -1
'Else
  'got it, unless it's null
 ' getPlantConceptIDfromZB_ID = Nz(rstCurr!PLANTCONCEPT_ID, -1)
'End If
'End Function


Public Function populate_Z_B_LkNms_oldWay(Optional blnDontOpenForm As Boolean)
  ''populates the Z_B_VBLookup_Nms table with names, then gets all concept_ID and name_ID's for those

  Debug.Print "populate_Z_B_LkNms >> init. " & Now()
  rereshCurrForm
  ''first runSQL to update all plantNameID's and conceptID's to null
  DoCmd.OpenQuery "plantMatch_null_blankAccession"
  'check any present accessionCodes
  DoCmd.OpenQuery "plantMatch_nullFalseAccessions"
  
  'make sure partyAccessionCodes are same as party_ID in Priority Lookup
  DoCmd.OpenQuery "Z_B_Lookup_updateP_IDFrmAcc"
  
  txa_addNames "Z_USER_B_specList", "plantName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 3, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantShortName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "OtherPlantName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantCommonName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantParent", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantSyn1", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantSyn2", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantSyn3", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_B_specList", "plantSyn4", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_D2_StrataCover", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_D_CoverData", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  txa_addNames "Z_USER_E_StemData", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  Debug.Print "populate_Z_B_LkNms >> names added. " & Now()
  ''delete plant names no longer in use:
  DoCmd.RunSQL "DELETE Z_B_VB_LookUpNms.* FROM Z_B_VB_LookUpnms WHERE plantAsConc = -1;", False
  
  Dim rstNames As New ADODB.Recordset
  rstNames.Open "select * from Z_B_VB_LookupNms WHERE accessionCode is null;", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  
  ''update NewPlantConcept field in Z_USER_B_SpecList to make only new concepts be added (new concept = -1)
'@34  DoCmd.RunSQL "UPDATE Z_USER_B_SpecList SET NewPlantConcept = false;"
  
  With rstNames
    ''fill in name_ID's and concept_ID's
    Do Until .EOF
       If Not IsNull(!accessionCode) Then
         'confirm that it is still here and move on
         Dim lngConfirmAcc As Long
         lngConfirmAcc = getPKfromAccessionCode(!accessionCode, "plantConcept")
         If lngConfirmAcc = !PLANTCONCEPT_ID Then
           'accession code still found and legit
           'keep data and move on
           GoTo AccessionCodeOK
         Else
           'remove accessionCode- not found on vegbank_module any longer
           !accessionCode = Null
           'then go through normal process again
         End If
       End If
       !PLANTNAME_ID = Get_PlantName_ID(!plantName)
       If !plantAsConc > 1 Then
        ' If !plantNAme_ID <> -1 Then  ''could not find name
           Dim lngParty As Long, strNameFound As String, lngTempConc As Long
           strNameFound = ""
           lngTempConc = InterpretPlName_PlConc(!plantName, , strNameFound)
           !PLANTCONCEPT_ID = lngTempConc
           'update name that was used to find concept
           !linkedThrough = strNameFound
           If lngTempConc <> -1 Then
             !accessionCode = getAccessionCode("plantConcept", lngTempConc)
           End If
           If !PLANTCONCEPT_ID = -1 Then
             'new plant concept
       '@34      DoCmd.RunSQL "UPDATE Z_USER_B_SPecLIST SET NewPlantConcept=true WHERE plantCode = """ & !plantName & """;"
           End If
           !PARTY_ID = lngParty
        ' Else
         '  'could not find name, therefore could not find concept
          ' !PLANTCONCEPT_ID = -1
        ' End If
       Else
         'name not used as a concept, set to null
           !PLANTCONCEPT_ID = Null
           Dim lngTemp As Long
           lngTemp = getPlantReferenceOfNm(!plantName)
           If lngTemp <> -1 Then
             !PLANTREFERENCE_ID = lngTemp
           End If
       End If 'Plant as concept
     
     
     
       .Update
AccessionCodeOK:
    .MoveNext
    Loop
  End With
    
  Debug.Print "END:" & Now()
  If Not blnDontOpenForm Then
    DoCmd.OpenForm "Z_USER_B_vb_View"
    recalcCurrForm (True)
  End If
End Function

Public Function depopulate_Z_B_LkNms()
  If AreYouSure("Do you really want to remove all matches of plant names and start again with matching?") Then
    DoCmd.RunSQL "delete * from Z_B_VB_lookupNms;"
    recalcCurrForm True, True
    msgBox "Plant Matches erased.  Press the 'match plants' button to start matching again."
  End If
  
End Function

Public Function populate_Z_B_LkNms(Optional blnDontOpenForm As Boolean, Optional strOnlyOneName As String, Optional blnNoAdd As Boolean)
  ''populates the Z_B_VBLookup_Nms table with names, then gets all concept_ID and name_ID's for those

  Debug.Print "populate_Z_B_LkNms >> init. " & Now() & "  only1?:" & strOnlyOneName
  rereshCurrForm
If strOnlyOneName = "" Then
  ''first runSQL to update all plantNameID's and conceptID's to null
  DoCmd.OpenQuery "plantMatch_null_blankAccession"
  'check any present accessionCodes
  DoCmd.OpenQuery "plantMatch_nullFalseAccessions"
  'fix any invalid values:
  Call removeInvalidPlantMatches
  
  'make sure partyAccessionCodes are same as party_ID in Priority Lookup
  DoCmd.OpenQuery "Z_B_Lookup_updateP_IDFrmAcc"
  
  'update potential class 3 plants not currently class 3
  DoCmd.RunSQL "UPDATE Z_B_VB_LookupNms SET Z_B_VB_LookupNms.plantAsConc = 3 " _
& " WHERE (((Z_B_VB_LookupNms.plantAsConc)<3) AND ((Z_B_VB_LookupNms.plantName) in (select plantCode from Z_B_allNamesAsConc_cl3))); "

  'add new class 3 plantCodes
  DoCmd.RunSQL "INSERT INTO Z_B_VB_LookupNms ( plantName, plantAsConc ) " _
& " SELECT Z_B_allNamesAsConc_cl3.plantcode, Z_B_allNamesAsConc_cl3.classType " _
& " FROM Z_B_allNamesAsConc_cl3 LEFT JOIN Z_B_VB_LookupNms ON Z_B_allNamesAsConc_cl3.plantcode = Z_B_VB_LookupNms.plantName " _
& " WHERE (((Z_B_VB_LookupNms.plantName) Is Null) and (Z_B_allNamesAsConc_cl3.plantcode is not null)); "
  
  'update potential class 2 plants less than currently class 2
  DoCmd.RunSQL "UPDATE Z_B_VB_LookupNms SET Z_B_VB_LookupNms.plantAsConc = 2 " _
& " WHERE (((Z_B_VB_LookupNms.plantAsConc)<2) AND ((Z_B_VB_LookupNms.plantName) in (select plantCode from Z_B_allNamesAsConc_cl2))); "

  'add new class 2 plantCodes
  DoCmd.RunSQL "INSERT INTO Z_B_VB_LookupNms ( plantName, plantAsConc ) " _
& " SELECT Z_B_allNamesAsConc_cl2.plantcode, Z_B_allNamesAsConc_cl2.classType " _
& " FROM Z_B_allNamesAsConc_cl2 LEFT JOIN Z_B_VB_LookupNms ON Z_B_allNamesAsConc_cl2.plantcode = Z_B_VB_LookupNms.plantName " _
& " WHERE (((Z_B_VB_LookupNms.plantName) Is Null) and (Z_B_allNamesAsConc_cl2.plantcode is not null)); "
    'add new class 1 plantCodes
  DoCmd.RunSQL "INSERT INTO Z_B_VB_LookupNms ( plantName, plantAsConc ) " _
& " SELECT Z_B_allNamesAsConc_cl1.plantcode, Z_B_allNamesAsConc_cl1.classType " _
& " FROM Z_B_allNamesAsConc_cl1 LEFT JOIN Z_B_VB_LookupNms ON Z_B_allNamesAsConc_cl1.plantcode = Z_B_VB_LookupNms.plantName " _
& " WHERE (((Z_B_VB_LookupNms.plantName) Is Null) and (Z_B_allNamesAsConc_cl1.plantcode is not null)); "
    
  
 ' txa_addNames "Z_USER_B_specList", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 3, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantShortName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "OtherPlantName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantCommonName", "Z_B_VB_LookupNms", "plantName", False, 1, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantParent", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantSyn1", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantSyn2", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantSyn3", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_B_specList", "plantSyn4", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_D2_StrataCover", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_D_CoverData", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
 ' txa_addNames "Z_USER_E_StemData", "plantcode", "Z_B_VB_LookupNms", "plantName", False, 2, "plantAsConc"
  Debug.Print "populate_Z_B_LkNms >> names added. " & Now()
  ''delete plant names no longer in use:
  
    DoCmd.RunSQL "DELETE Z_B_VB_LookUpNms.* FROM Z_B_VB_LookUpnms WHERE plantAsConc = -1;"
Else
  'only doing one name, different handling, make sure it is in the list
  If "yes" <> getvalFrmSQL("select 'yes' from Z_B_VB_lookupNms where plantName=" & SQLizeTxt(strOnlyOneName)) And Not blnNoAdd Then
     'need to add, but how?
     ' first check to see if in species list
     Dim intPlantAs As Integer
     If IsPlantInSppList(strOnlyOneName) Then
       intPlantAs = 3
     Else 'not 3
       If getvalFrmSQL("select 'yes' from Z_B_allNamesAsConc_cl2 where plantCode=" & SQLizeTxt(strOnlyOneName)) = "yes" Then
         intPlantAs = 2
       Else 'not 2
         intPlantAs = 1
       End If
     End If
     DoCmd.RunSQL "INSERT INTO Z_B_VB_LookupNms ( plantName, plantAsConc ) SELECT " & SQLizeTxt(strOnlyOneName) & "," & intPlantAs
  End If
   
   
End If 'only one

'add any "sp." records to Z_USER_B if not already there
DoCmd.OpenQuery "SpecList_handleGenusSpSituation"
  
  
  Dim rstNames As New ADODB.Recordset
  rstNames.Open "select * from Z_B_VB_LookupNms WHERE accessionCode is null" & IIf(strOnlyOneName = "", "", " AND (plantNAme=" & SQLizeTxt(strOnlyOneName) & " OR linkedThrough=" & SQLizeTxt(strOnlyOneName) & ")"), CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  
  ''update NewPlantConcept field in Z_USER_B_SpecList to make only new concepts be added (new concept = -1)
'@34  DoCmd.RunSQL "UPDATE Z_USER_B_SpecList SET NewPlantConcept = false;"
  
  With rstNames
    ''fill in name_ID's and concept_ID's
    Do Until .EOF
       If Not IsNull(!accessionCode) Then
         'confirm that it is still here and move on
         Dim lngConfirmAcc As Long
         lngConfirmAcc = getPKfromAccessionCode(!accessionCode, "plantConcept")
         If lngConfirmAcc = !PLANTCONCEPT_ID Then
           'accession code still found and legit
           'keep data and move on
           GoTo AccessionCodeOK
         Else
           'remove accessionCode- not found on vegbank_module any longer
           !accessionCode = Null
           'then go through normal process again
         End If
       End If
       !PLANTNAME_ID = Get_PlantName_ID(!plantName)
       If !plantAsConc > 1 Then
        ' If !plantNAme_ID <> -1 Then  ''could not find name
           Dim lngParty As Long, strNameFound As String, lngTempConc As Long
           strNameFound = ""
           Dim strNotes As String
           strNotes = ""
           lngTempConc = InterpretPlName_PlConc(!plantName, , strNameFound, , strNotes)
           !PLANTCONCEPT_ID = lngTempConc
           'update name that was used to find concept
           !linkedThrough = strNameFound
           !notes = strNotes
           !PLANTNAME_ID = Get_PlantName_ID(!linkedThrough)
           If lngTempConc <> -1 Then
             !accessionCode = getAccessionCode("plantConcept", lngTempConc)
           End If
           If !PLANTCONCEPT_ID = -1 Then
             'new plant concept
       '@34      DoCmd.RunSQL "UPDATE Z_USER_B_SPecLIST SET NewPlantConcept=true WHERE plantCode = """ & !plantName & """;"
           End If
           !PARTY_ID = lngParty
        ' Else
         '  'could not find name, therefore could not find concept
          ' !PLANTCONCEPT_ID = -1
        ' End If
       Else
         'name not used as a concept, set to null
           !PLANTCONCEPT_ID = Null
           Dim lngTemp As Long
           lngTemp = getPlantReferenceOfNm(!plantName)
           If lngTemp <> -1 Then
             !PLANTREFERENCE_ID = lngTemp
           End If
       End If 'Plant as concept
     
     
     
       .Update
AccessionCodeOK:
    .MoveNext
    Loop
  End With
    
  Debug.Print "END:" & Now()
  If Not blnDontOpenForm Then
    DoCmd.OpenForm "Z_USER_B_vb_View"
    recalcCurrForm (True)
  End If
End Function

Public Function IsPlantInSppList(strName As String) As Boolean
  IsPlantInSppList = getvalFrmSQL("select true from Z_USER_B_specList where plantCode=" & SQLizeTxt(strName))
End Function

Public Function removeInvalidPlantMatches()
  'function removes any invalid plant matches from the matching table, such as those with "" as plant name or null
  ' and any that have null values for plantConcept_ID

    DoCmd.RunSQL "DELETE * FROM chk_B_invalid_lookup;"

End Function

Public Function getPlantReferenceOfNm(strName As String) As Long
''fill in plant Name References, from Y_plantReferenceTranslation
  Dim rstZB As New ADODB.Recordset
  rstZB.Open "SELECT namesReference FROM z_USER_B_SpecList WHERE plantCode = " & SQLizeTxt(strName, "'") _
     & " OR plantName = " & SQLizeTxt(strName, "'") & " OR plantShortName = " & SQLizeTxt(strName, "'") _
     & " OR OtherplantName = " & SQLizeTxt(strName, "'") & " OR plantCommonName = " & SQLizeTxt(strName, "'") & ";" _
      , CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
  If Not rstZB.EOF Then
    getPlantReferenceOfNm = get_Ref(Nz(rstZB!NamesReference, ""))
  Else
    ''cant find name in Z_B where reference exists
    getPlantReferenceOfNm = -1
  End If
  rstZB.Close
End Function

Public Function txa_addNames(strTbl As String, strFld As String, destTbl As String, destFld As String, _
    blnInclNulls As Boolean, Optional intExtraVal As Integer, Optional strExtraFld As String)
  ''adds all strings in strFld in strTbl to destFld in destTbl: blnInclNulls=true adds nulls
  Dim rstSrc As New ADODB.Recordset
  Dim rstDest As New ADODB.Recordset
  rstSrc.Open "SELECT [" & strFld & "] FROM [" & strTbl & "]", CurrentProject.Connection, _
      adOpenForwardOnly, adLockReadOnly, adCmdText
  With rstSrc
  Do Until .EOF
    If (blnInclNulls) Or Not (IsNull(.Fields(strFld))) Then
      'open recordset with destination set, to add field value if not found there:
      If IsNull(.Fields(strFld)) Then
        rstDest.Open "SELECT * FROM [" & destTbl & "] WHERE [" & destFld & "] is null ;" _
          , CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
      Else
        rstDest.Open "SELECT * FROM [" & destTbl & "] WHERE [" & destFld & "] = " & SQLizeTxt(.Fields(strFld), "'") & ";" _
          , CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
      End If
      If rstDest.EOF Then
        ''add new
        rstDest.AddNew
        'check to see if string > 255, if so add real name to *HARDCODE* linkedThrough
        If Len(.Fields(strFld)) > 255 Then
         rstDest.Fields(destFld) = Left(.Fields(strFld), 255)
         rstDest!linkedThrough = .Fields(strFld)
        Else
         rstDest.Fields(destFld) = .Fields(strFld)
        End If
        rstDest.Update
      End If
        ''if extra value is passed, make sure that it overwrites old value in extra field:
        If (intExtraVal) <> 0 Then
       ''   Debug.Print "EV:_" & strExtraVal & "_"
          If rstDest.Fields(strExtraFld) < intExtraVal Or IsNull(rstDest.Fields(strExtraFld)) Then
            'update to new value
            rstDest.Fields(strExtraFld) = intExtraVal
            rstDest.Update
          End If
        End If
      
      ''close destination rst
      rstDest.Close
    End If
  .MoveNext
  Loop
  End With

End Function

'Public Function Populate_Z_B_VBLookup()
  ''defunct!--
  ''populates the table Z_B_VBLookup with plantName_ID's and plantConcept_ID's and plantRef_ID's
  ''clear current contents:
'  DoCmd.RunSQL "DELETE * FROM Z_B_VBLookup;"
 ' Dim rstSrc As New ADODB.Recordset
  'Dim rstDest As New ADODB.Recordset
'  rstSrc.Open "Z_USER_B_SpecList", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdTable
 ' rstDest.Open "Z_B_VBLookup", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdTable
  'With rstSrc
 
'  Do Until .EOF
 '     rstDest.AddNew
  '    rstDest!UserPlant_ID = !UserPlant_ID
   '   rstDest!PLANTREFERENCE_ID = get_Ref(Nz(!reference, ""))
 ''add values as they apply : skip if the base value is null:
'If Not IsNull(!plantCode) Then
'rstDest!plantCode_ID = Get_PlantName_ID(!plantCode)
'End If
'If Not IsNull(!plantName) Then
'rstDest!plantNAme_ID = Get_PlantName_ID(!plantName)
'End If
'If Not IsNull(!plantShortName) Then
'rstDest!plantShortName_ID = Get_PlantName_ID(!plantShortName)
'End If
'If Not IsNull(!plantCommonName) Then
'rstDest!plantCommonName_ID = Get_PlantName_ID(!plantCommonName)
'End If
'If Not IsNull(!otherPlantName) Then
'rstDest!OtherplantName_ID = Get_PlantName_ID(!otherPlantName)
'End If
'If Not IsNull(!plantName) Then
'rstDest!PLANTCONCEPT_ID = InterpretPlName_PlConc(!plantName)
'End If
'If Not IsNull(!plantParent) Then
'rstDest!plantParentConcept_ID = InterpretPlName_PlConc(!plantParent)
'End If
'If Not IsNull(!plantSyn1) Then
'rstDest!syn1_Concept_ID = InterpretPlName_PlConc(!plantSyn1)
'End If
'If Not IsNull(!plantSyn2) Then
'rstDest!syn2_Concept_ID = InterpretPlName_PlConc(!plantSyn2)
'End If
'If Not IsNull(!plantSyn3) Then
'rstDest!syn3_Concept_ID = InterpretPlName_PlConc(!plantSyn3)
'End If
'If Not IsNull(!plantSyn4) Then
'rstDest!syn4_Concept_ID = InterpretPlName_PlConc(!plantSyn4)
'End If
'      rstDest.Update
'  .MoveNext
'  Loop
'  End With
'
'End Function

Public Function get_Ref(strRef As String, Optional blnDblCheck As Boolean) As Long
 ''translates reference string into an actual reference, based on table: y_plantreferencetranslation
 Dim rstRef As New ADODB.Recordset
 rstRef.Open "SELECT * FROM Z_VB_reconcile WHERE LoadVarName = ""Reference"" and LoadVarValue = " _
    & SQLizeTxt(strRef, "'") & ";", CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
 If rstRef.EOF Then
   ''can't get reference, pass back -1
   get_Ref = -1
 Else
   'got ref
   get_Ref = Nz(rstRef!VBFieldValue, -1)
   If blnDblCheck Then
     ''check to make sure that the Ref_ID makes sense:
     Dim rstRef2 As New ADODB.Recordset '
     rstRef2.Open "SELECT * FROM Reference WHERE Reference_ID = " & Nz(rstRef!VBFieldValue, -1), _
        CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
     If rstRef2.EOF Then
       ''plantREference ID cannot be found
       get_Ref = -1
     End If
     rstRef2.Close
   End If
 End If

End Function


Public Function add_plantName_to_VB(strPlantName As String, lngRef As Long) As Long
  'adds a plant name to the plantName table in the vegbank module : returns plantNAme_ID
Debug.Print "add_plantName_to_VB >> " & strPlantName
  If strPlantName <> "" Then
    Dim rstChkDupl As New ADODB.Recordset
    rstChkDupl.Open "SELECT * FROM plantName WHERE plantName = " & SQLizeTxt(strPlantName, "'") & ";", _
       CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
    If rstChkDupl.EOF Then
      rstChkDupl.AddNew
      rstChkDupl!plantName = strPlantName
      rstChkDupl!dateEntered = Now()
      If lngRef <> -1 Then
        rstChkDupl!REFERENCE_ID = lngRef
      End If
      rstChkDupl.Update
      add_plantName_to_VB = rstChkDupl!PLANTNAME_ID
      rstChkDupl.Close
    Else
      'plantName already there
      Debug.Print "plant Name already in plantNAme:" & strPlantName
      add_plantName_to_VB = rstChkDupl!PLANTNAME_ID
    End If
  End If
End Function

Public Function add_ALL_new_plantNAmesToVB()
''function adds new plant names (as signified by plantName_ID = -1 in Z_B_VB_lookupNms) to vegbank module
Debug.Print "add_ALL_new_plantNAmesToVB >> init."
Dim rstNewPl As New ADODB.Recordset
  rstNewPl.Open "SELECT * FROM Z_B_VB_lookupNms WHERE plantNAme_ID = -1", _
  CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  With rstNewPl
  Do Until .EOF
     ''loop thru each record and add new plantNAme, updating plantName_ID
     !PLANTNAME_ID = add_plantName_to_VB(!plantName, Nz(!PLANTREFERENCE_ID, -1))
     .Update
  .MoveNext
  Loop
  End With
End Function


Public Function add_plantConc_to_VB(strPlantName As String, lngRef As Long, Optional strDesc As String) As Long
   ' Optional strLevl As String, Optional lngParentConc As Long) As Long
  'adds a plant concept to the plantConcept table in the vegbank module : returns plantConcept_ID
Debug.Print "add_plantConc_to_VB >> plant: " & strPlantName & " ; REF: " & lngRef
  ''check to make sure valid name and reference:
  Dim lngPlNm As Long
  lngPlNm = Get_PlantName_ID(strPlantName, True) 'add if not found
  If lngPlNm = -1 Then
     Debug.Print strPlantName & " is not a valid plant name : SHOULD NEVER HAPPEN!"
  End If
  Dim rstRefChk As New ADODB.Recordset
  rstRefChk.Open "SELECT * FROM REference WHERE Reference_ID = " & lngRef, CurrentProject.Connection _
    , adOpenForwardOnly, adLockReadOnly, adCmdText
  If rstRefChk.EOF Then
    'not a valid reference:
    msgBox "Your reference was not valid, ID = " & lngRef & Chr(13) & "Skipping concept."
    Exit Function
  End If
   ''--reference and name have been checked, now add concept
  If strPlantName <> "" Then
    Dim rstChkDupl2 As New ADODB.Recordset
    rstChkDupl2.Open "SELECT * FROM plantConcept WHERE plantName_ID = " & lngPlNm & " AND Reference_ID = " & lngRef & ";", _
      CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
    With rstChkDupl2
    If .EOF Then  'could not find concept, add a new one
      .AddNew
''      Debug.Print "adding new:" & !PLANTCONCEPT_ID
      ''add new data for concept as applicable
      !PLANTNAME_ID = lngPlNm
      !REFERENCE_ID = lngRef
      If strDesc <> "" Then
        !plantDescription = strDesc
      End If
     ' If strLevl <> "" Then
      '  !plantLevel = strLevl
     ' End If
     ' If lngParentConc <> 0 Then
      '  !plantParent = lngParentConc
     ' End If
      !plantName = strPlantName
      'add accessionCode
      !accessionCode = writeNewAccCode("plantConcept", !PLANTCONCEPT_ID)
      .Update

      add_plantConc_to_VB = !PLANTCONCEPT_ID
    Else
      'plantConcept already exists!
      Debug.Print "plant Concept already in plantConcept:" & strPlantName & " _ref_:" & lngRef
      add_plantConc_to_VB = !PLANTCONCEPT_ID
    End If
    End With
    rstChkDupl2.Close
  End If
End Function

Function testPLCONCLOAD()
  add_ALL_new_plantConcToVB True
End Function

Public Function add_ALL_new_plantConcToVB(blnAddEverything As Boolean)
''function adds new concepts to VegBank module, given Z_USER_B_specList.NewPlantConcept = true
  ''if blnAddEverything then it adds new concepts with Status and Usage as well.
Debug.Print "add_ALL_new_plantConcToVB >> init."
 If blnAddEverything Then
   'need plant Party:
   Dim lngparty_ID As Long
   lngparty_ID = getPartyID()
   If lngparty_ID = -1 Then
     ''can't get party
     Debug.Print "CAN't GET PLANT PARTY!!"
     Exit Function
   End If
 End If
 Dim dtNow As Date
 dtNow = Now()
 
 Dim rstNewCnc As New ADODB.Recordset
  rstNewCnc.Open "SELECT * FROM Z_USER_B_specList WHERE NewPlantConcept = true AND archivedStatus = 0 ", _
     CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  With rstNewCnc
  If .EOF Then Debug.Print "NO NEW CONCEPTS ADDED!" & Now()
  Do Until .EOF
     ''loop thru each record and add new plantNAme, updating plantName_ID
     ''first, consider parent concept:
    
     Dim lngConc As Long
     Debug.Print "Adding concept for : " & !plantName & " ___ref___:" & !reference
     lngConc = add_plantConc_to_VB(!plantName, get_Ref(!reference), Nz(!plantDescription, ""))
          '  Nz(!plantLevel), lngParentConc)
            Debug.Print " concept ID = " & lngConc
     ''archive plantConcept ID in Z_B_VB_LookupNms
     Dim strSQL As String
     strSQL = "UPDATE Z_B_VB_LookupNms SET plantConcept_ID = " & lngConc & " WHERE plantName = " _
           & SQLizeTxt(!plantName, "'") & " OR plantName = " & SQLizeTxt(!plantCode, "'") & ";"
     'Debug.Print strSQL
     DoCmd.RunSQL strSQL, True
     
     'undo concepts which have been specified as a NEW concept manually -- has been added and is no longer new
     strSQL = "DELETE Z_VB_reconcile.* FROM Z_VB_reconcile " _
& " WHERE (((Z_VB_reconcile.LoadVarName)=""plantName"") AND ((Z_VB_reconcile.LoadVarValue)=" _
& SQLizeTxt(!plantCode, "'") & ") AND ((Z_VB_reconcile.VBTableName)=""plantConcept"") AND ((Z_VB_reconcile.VBFieldValue)=-1));"
     'Debug.Print strSQL
     DoCmd.RunSQL strSQL, True
     
     
     ''!VB_ConceptID = lngConc
     !ArchivedStatus = 1
     ''ADD status, correlation and usage, if asked for:
     If blnAddEverything Then
       ''add usage(s)!  -- so as to get concept back out with interpret_concept function
         ''addSetPlantUsages lngConc, lngParty, dtNow, !plantName, Nz(!plantNameSystem, ""), _
           Nz(!plantShortName, ""), Nz(plantShortNameSystem, ""), Nz(plantCommonName, ""), _
           Nz(plantCommonNameSystem, ""), Nz(otherPlantName, ""), Nz(otherPlantNameSystem, "")
addSetPlantUsages lngConc, lngparty_ID, dtNow, !plantName, Nz(!plantNameSystem, ""), Nz(!plantNameStatus, "standard"), _
Nz(!plantShortName, ""), Nz(!plantShortNameSystem, ""), Nz(!plantShortNameStatus, "standard"), _
Nz(!plantCommonName, ""), Nz(!plantCommonNameSystem, ""), Nz(!plantCommonNameStatus, "standard"), _
Nz(!otherPlantName, ""), Nz(!otherPlantNameSystem, ""), Nz(!otherPlantNameStatus, "standard"), !plantCode
         
       ''add status
   '    Dim lngStatus As Long
    '   lngStatus = Add_PlantStatus_toVB(lngConc, lngparty_ID, (!plantConceptStatus), Now(), _
     '       False, False, , , Nz(!plantPartyComments, ""))
       'add correlations:
       !ArchivedStatus = 1.5
     End If
     
     
     .Update
  .MoveNext
  Loop
  End With
End Function

'Public Function getPlConc_fromLookup(strName As String) As Long
''function gets a plant concept ID from the Z_B_VB_lookupNms table, returning -1 if not found!
'Debug.Print "GETTING PL CONC FROM LOOKUP! defunct"
'Dim rstCurr As New ADODB.Recordset
'rstCurr.Open "SELECT * FROM Z_B_VB_LookupNms WHERE plantName = """ & strName & """;" _
'   , CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
'If rstCurr.EOF Then
'  ''not concept found by that name!
'  getPlConc_fromLookup = -1
'Else
'  getPlConc_fromLookup = Nz(rstCurr!PLANTCONCEPT_ID, -1)
'End If
'End Function

Public Function Add_PlantStatus_toVB(lngConc As Long, lngParty As Long, strStatus As String, dtStart As Date, _
    blnStop As Boolean, blnOldStatus As Boolean, Optional dtStop As Date, Optional lngRef As Long, _
   Optional strComments As String, Optional strLevel As String, Optional lngParent As Long) As Long
   Debug.Print "Add_PlantStatus_toVB >> Conc: " & lngConc & " ; Party: " & lngParty & " ; Status:" & strStatus
  ''function adds a plantStatus and returns the PK of that new status.
  ''---also sets old status record's stop date as the start date of this new record
  ''-- If this is a concept to be added before a current concept, then blnOldStatus should be true and the stopdate _
      for the new status will be the min of startDates for statuses with same concept and party
  Dim rstStat As New ADODB.Recordset
  rstStat.Open "SELECT * FROM plantStatus WHERE party_ID = " & lngParty & " AND plantConcept_ID = " & lngConc _
    , CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  With rstStat
  Do Until .EOF
     ''status(es) exist already for this party. Some changing of dates must be accomplished before adding new record
     If IsNull(!stopDate) And !startDate < dtStart Then
         ''stop this status, at the same date as the new status starts:
         !stopDate = dtStart
         .Update
     Else
        If !stopDate <= dtStart Then
          ''status ends before this start date -- leave it alone
        Else
          If !startDate > dtStart And blnOldStatus Then
            ''get date to turn off the new concept to add
            If dtStop <> 0 Then
              If !startDate < dtStop Then dtStop = !startDate
            Else
              dtStop = !startDate
            End If
            blnStop = True
          Else
            msgBox "The current Concept already has a status in effect for you for the same time " _
              & "period that you are trying to add.  No status added - Concept = " & lngConc
            Debug.Print "The current Concept already has a status in effect for you for the same time " _
              & "period that you are trying to add.  No status added - Concept = " & lngConc
              
            Add_PlantStatus_toVB = !PLANTSTATUS_ID
            GoTo NoStatusToAdd
          End If
        End If 'stop date before new record's start = OK
     End If
     .MoveNext
  Loop
  .AddNew
    !PLANTCONCEPT_ID = lngConc
    If lngRef <> 0 Then  '!0
       !REFERENCE_ID = lngRef
    End If
    !plantConceptStatus = strStatus
    !startDate = dtStart
    If blnStop Then
      !stopDate = dtStop
    End If
    If strComments <> "" Then
      !plantPartyComments = strComments
    End If
    !PARTY_ID = lngParty
    If strLevel <> "" Then
      !plantLevel = strLevel
    End If
    If lngParent <> 0 Then
      !plantPArent_ID = lngParent
    End If
    ''pass back status ID
    Add_PlantStatus_toVB = !PLANTSTATUS_ID
  .Update
  End With
NoStatusToAdd:
End Function

Public Function add_ALL_new_plantStatusCorrToVB() As Boolean
''function adds new statuses (AND CORRELATIONS) to VegBank module, given Z_USER_B_specList.AddPartyPerspective = true
Debug.Print "add_ALL_new_plantStatusCorrToVB >>  init. "
 'need plant Party:
Dim lngparty_ID As Long
lngparty_ID = getPartyID()
If lngparty_ID = -1 Then
  ''can't get party
  Exit Function
End If
Dim dtNow As Date
dtNow = Now()
 
 Dim rstNewCnc As New ADODB.Recordset
  rstNewCnc.Open "SELECT * FROM Z_USER_B_specList WHERE AddPartyPerspective = true AND archivedStatus < 2 ", _
     CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  With rstNewCnc
  Do Until .EOF
     ''loop thru each record and add new plantNAme, updating plantName_ID
     Debug.Print "adding status : " & !plantCode
     'add parent
      Dim lngParentConc As Long
     If IsNull(!plantPArent) Then
       lngParentConc = 0
     Else
       lngParentConc = IIf(IsNull(!plantPArent), 0, InterpretPlName_PlConc(!plantPArent, , , , , True))
       
       ''if no concept was found, don't pass a concept (pass 0, unfortunately)
       If lngParentConc = -1 Then
        lngParentConc = 0
        Debug.Print "not adding parent concept: " & !plantPArent
       End If
     End If
     Dim lngStatus As Long, lngConc As Long
     lngConc = InterpretPlName_PlConc(!plantCode, , , , , True)
     ''**TEST
     lngStatus = Add_PlantStatus_toVB(lngConc, lngparty_ID, !plantConceptStatus, _
            dtNow, False, False, , , Nz(!plantPartyComments), Nz(!plantLevel), lngParentConc)
     !ArchivedStatus = 2
     ''add any plant Correlations:
     Dim inttemp As Integer
     For inttemp = 1 To 4
      If Not IsNull(.Fields("plantSyn" & inttemp)) And Not IsNull(.Fields("plantSynConverg" & inttemp)) Then
        ''this set of convergence values exists!
        If Add_PlantCorr_toVB(lngStatus, InterpretPlName_PlConc(.Fields("plantSyn" & inttemp), , , , , True), _
           .Fields("plantSynConverg" & inttemp), dtNow, False) Then
           'successfully added Corr - update arc status:
           !ArchivedStatus = 3
        End If
      End If
     Next inttemp
     'update any usages here, with status_ID, too (NOV 5,2004)
     'rules: same party, same concept, null status_ID in usage, (endDate is null?)
     DoCmd.RunSQL "update plantUSage set plantStatus_ID=" & lngStatus & " WHERE plantConcept_ID=" & lngConc & " and party_ID=" _
       & lngparty_ID & " AND usageStop IS NULL;"
     
     .Update
  .MoveNext
  Loop
  End With
  'function executes properly : plantPartyID is correctly found
  add_ALL_new_plantStatusCorrToVB = True
End Function

Public Function Add_PlantCorr_toVB(lngStatus As Long, lngConc As Long, strConverg As String, dtStart As Date, _
    blnStop As Boolean, Optional dtStop As Date) As Boolean
    ''function adds a plantCorrelation, given a plantStatus, plantConcept, convergence, startdate, and optionally a stop date
    On Error GoTo Corr_Error
Debug.Print "Add_PlantCorr_toVB >> Conc: " & lngConc & " ;  Status:" & lngStatus & " Convg: " & strConverg
   Dim rstCorr As New ADODB.Recordset
   'open correlation
   rstCorr.Open "plantCorrelation", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdTable
   With rstCorr
     'add new record
     .AddNew
     !PLANTSTATUS_ID = lngStatus
     !PLANTCONCEPT_ID = lngConc
     !plantConvergence = strConverg
     !CorrelationStart = dtStart
     'add stop date if there is one
     If blnStop Then
       !CorrelationStop = dtStop
     End If
     'update changes
     .Update
   End With
   Add_PlantCorr_toVB = True
   Exit Function
Corr_Error:
  'error in process, report it and exit
   msgBox "There was an error in trying to add a plantCorrelation: Status = " & lngStatus & _
      " ; Concept = " & lngConc & Chr(13) & Err.Description
      Debug.Print "PlantCorrelation Error: STatus " & lngStatus & " ; Concept: " & lngConc
    Add_PlantCorr_toVB = False
End Function

Public Function add_ALL_plantUsage_nonNew()
 ''adds plant Usages to VegBank that are not a new concept --
 ''i.e. adds part of the party perspective to old concepts
Debug.Print "add_ALL_plantUsage_nonNew >> init."
 'need plant Party:
Dim lngparty_ID As Long
lngparty_ID = getPartyID()
If lngparty_ID = -1 Then
  ''can't get party
  Exit Function
End If
'date
Dim dtNow As Date
dtNow = Now()
Dim rstUsage As New ADODB.Recordset
''open recordset of usages to add
rstUsage.Open "SELECT * FROM Z_USER_B_SpecList WHERE archivedStatus <1.5 AND newplantConcept <> true and addPartyPErspective = true" _
   , CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
With rstUsage
Do Until .EOF
  Debug.Print "ADDING USAGE for " & !plantCode
  ''get current concept ID
  Dim lngConc As Long
  lngConc = InterpretPlName_PlConc(!plantCode, , , , , True)
  ''append names to concept as usages for the curr party
addSetPlantUsages lngConc, lngparty_ID, dtNow, !plantName, Nz(!plantNameSystem, ""), Nz(!plantNameStatus, "standard"), _
Nz(!plantShortName, ""), Nz(!plantShortNameSystem, ""), Nz(!plantShortNameStatus, "standard"), _
Nz(!plantCommonName, ""), Nz(!plantCommonNameSystem, ""), Nz(!plantCommonNameStatus, "standard"), _
Nz(!otherPlantName, ""), Nz(!otherPlantNameSystem, ""), Nz(!otherPlantNameStatus, "standard"), !plantCode
 !ArchivedStatus = 1.5
 .Update
.MoveNext
Loop
End With

End Function

Public Function Add_PlantUsage_toVB(lngConc As Long, lngName As Long, strNameStatus As String, strClassSys As String, _
    lngParty As Long, dtStart As Date, blnStop As Boolean, blnOldUsg As Boolean, Optional dtStop As Date) As Boolean
''function adds a plantUsage, given a plantNAme, plantConcept,classSystem, nameStatus , startdate, and optionally a stop date
 '   On Error GoTo USage_Error
Debug.Print "Add_PlantUsage_toVB >> Conc: " & lngConc & " ; Party: " & lngParty & " ; Name:" & lngName & " NStatus: " & strNameStatus
  ''---also sets old usage record's stop date as the start date of this new record
  ''-- If this is a concept to be added before a current concept, then blnOldUsg should be true and the stopdate _
      for the new usage will be the min of startDates for startuses with same concept and party, and classSystem
  'get classSystem SQL clause:
  Dim strClassSQL As String
  If strClassSys = "" Then
    strClassSQL = " AND ((classSystem) is null)  "
  Else
    strClassSQL = " AND classSystem = " & SQLizeTxt(strClassSys, "'")
  End If
  
  Dim rstUSG As New ADODB.Recordset
  rstUSG.Open "SELECT * FROM plantUsage WHERE party_ID = " & lngParty & " AND plantConcept_ID = " & lngConc _
    & strClassSQL & " AND plantNameStatus = ""standard""", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
  With rstUSG
  Do Until .EOF
    If !plantNameStatus = "standard" And strNameStatus = "standard" Then
      ''std Usg(es) exist already for this party. Some changing of dates must be accomplished before adding new std record
     If IsNull(!usageStop) And !usageStart < dtStart Then
         ''stop this status, at the same date as the new status starts:
         !usageStop = dtStart
         .Update
     Else
        If !usageStop <= dtStart Then
          ''status ends before this start date -- leave it alone
        Else
          If !usageStart > dtStart And blnOldUsg Then
            ''get date to turn off the new concept to add
            If dtStop <> 0 Then
              If !usageStart < dtStop Then dtStop = !usageStart
            Else
              dtStop = !usageStart
            End If
            blnStop = True
          Else
            msgBox "The current Concept - system already has a usage in effect for you for the same time " _
              & "period that you are trying to add.  No usage added - Concept = " & lngConc
            GoTo NoUsgToAdd
          End If
        End If
     End If
    End If
     .MoveNext
  Loop
  
  .AddNew
    'add new usage:
    ''lngConc As Long, lngName As Long, strNameStatus As String, strClassSys As String, _
    lngParty As Long, dtStart As Date, blnStop As Boolean, blnOldUsg As Boolean, Optional dtStop
    !PLANTCONCEPT_ID = lngConc
    !PLANTNAME_ID = lngName
    !plantNameStatus = strNameStatus
    If strClassSys <> "" Then
      !classSystem = strClassSys
    End If
    !usageStart = dtStart
    If blnStop Then
      !usageStop = dtStop
    End If
    !PARTY_ID = lngParty
    .Update
  End With
  Add_PlantUsage_toVB = True
NoUsgToAdd:
Exit Function
USage_Error:
  'error in process, report it and exit
   msgBox "There was an error in trying to add a plantUSage: Name = " & lngName & _
      " ; Concept = " & lngConc & Chr(13) & Err.Description
      Debug.Print "PlantUSG Error: Name " & lngName & " ; Concept: " & lngConc
    Add_PlantUsage_toVB = False
End Function

Public Function addSetPlantUsages(lngConc As Long, lngParty As Long, dtNow As Date, _
strPlantName As String, strPlantNameSystem As String, strPlantNameStatus As String, _
strPlantShortName As String, strPlantShortNameSystem As String, strPlantShortNameStatus As String, _
strPlantCommonName As String, strPlantCommonNameSystem As String, strPlantCommonNameStatus As String, _
strOtherPlantName As String, strOtherPlantNameSystem As String, strOtherPlantNameStatus As String, _
  strCode As String)
''adds a set of plant Usages
Debug.Print "addSetPlantUsages >> " & lngConc & " : " & strPlantName; " ; " & strPlantShortName & " ; " _
   & strPlantCommonName & " ; " & strOtherPlantName
'plantName - primary name
         Add_PlantUsage_toVB lngConc, Get_PlantName_ID(strPlantName, True), (strPlantNameStatus), _
           (strPlantNameSystem), lngParty, dtNow, False, False
'plantShortName, if not null
         If Not ("" = (strPlantShortName)) Then
           Add_PlantUsage_toVB lngConc, Get_PlantName_ID(strPlantShortName, True), (strPlantShortNameStatus), _
           (strPlantShortNameSystem), lngParty, dtNow, False, False
         End If
'plantCommonName, if not null
         If Not ("" = (strPlantCommonName)) Then
           Add_PlantUsage_toVB lngConc, Get_PlantName_ID(strPlantCommonName, True), (strPlantCommonNameStatus), _
           (strPlantCommonNameSystem), lngParty, dtNow, False, False
         End If
'OtherplantName, if not null
         If Not ("" = (strOtherPlantName)) Then
           Add_PlantUsage_toVB lngConc, Get_PlantName_ID(strOtherPlantName, True), (strOtherPlantNameStatus), _
           (strOtherPlantNameSystem), lngParty, dtNow, False, False
         End If
'code, if not null AND if codes are to be added:
     If getMetaData2Value("MigratePlantCodes") Then
         If Not ("" = (strCode)) Then
           Add_PlantUsage_toVB lngConc, Get_PlantName_ID(strCode, True), ("standard"), _
           ("CODE"), lngParty, dtNow, False, False
         End If
     End If
End Function

Public Function plant_Txa_CompletePkgMigr()
  Debug.Print "plant_Txa_CompletePkgMigr >> init."
  ''import
'skip:  populate_Z_B_LkNms (True)
  ''check and verify, then:
  '<!--  /*  // @comment@ */ -->
  ''only add plants if there is something to add:
  Dim rstPlants As New ADODB.Recordset
  rstPlants.Open "SELECT count(UserPlant_ID) as z__NumPlnts FROM Z_user_b_SpecList WHERE NewPlantConcept=true or AddPartyPerspective=true;", _
    CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
  If rstPlants!Z__NumPlnts > 0 Then
   ' add_ALL_new_plantNAmesToVB ' ADDED ON DEMAND!
    add_ALL_new_plantConcToVB True '' includes usages
    'now non new usages:
    add_ALL_plantUsage_nonNew
    'now all statuses and correlations :
    Debug.Print "It is " & add_ALL_new_plantStatusCorrToVB & " that statuses were successfully added"
    Call update_plantName_ConcUsg
  Else
    Debug.Print "plant_Txa_CompletePkgMigr >> no plants to add"
  End If
End Function


Public Function get_plantStatusTxt_fromID(lngStatus As Long) As String
  ''function returns the string "accepted" or "not accepted" for a status_ID
  Dim rstStatus As New ADODB.Recordset
  rstStatus.Open "SELECT * FROM plantStatus WHERE plantStatus_ID = " _
     & lngStatus, CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
  If Not rstStatus.EOF Then
    get_plantStatusTxt_fromID = rstStatus!plantConceptStatus
  End If
End Function

Public Function get_plantStatusID(lngConc, lngParty, dtDate As Date)
  ''function gets a plantStatus ID, given a concept, PArty and date
  Dim rstStatus As New ADODB.Recordset
  rstStatus.Open "SELECT plantSTatus_ID FROM plantStatus WHERE plantConcept_ID = " _
     & lngConc & " AND party_ID = " & Nz(lngParty, -1) & " AND startDate < #" _
     & dtDate & "# AND ((stopDate > #" & dtDate & "#) OR ((stopDate) is null))", _
       CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly, adCmdText
  Dim lngRet As Long
  'default to not found
  lngRet = -1
  With rstStatus
  Do Until .EOF
    If lngRet = -1 Then
      ''found status
      lngRet = !PLANTSTATUS_ID
    Else
      'found too many statuses (>1)
      lngRet = -2
      GoTo ExitGetStatus
    End If
  .MoveNext
  Loop
  End With
ExitGetStatus:
get_plantStatusID = lngRet
End Function

Public Function testewtajlfjlsafds()
   Debug.Print pltxa_ReturnPlantName_ID(-71, "get")
End Function

Public Function pltxa_ReturnPlantConcept_ID(lngConc As Long, GetPut As String) As Long
''function deals with browsing for plant concept (from Browse for file model):
    On Error GoTo StoreFileErr:
GoTo Past_err
StoreFileErr:
  msgBox "Error in storing plant concept ID!" & Chr(13) & Err.Description, vbCritical
  Exit Function
Past_err:
Static lngPlantConceptInMem As Long
If GetPut = "put" Then
  lngPlantConceptInMem = lngConc
  'use other storing method, too
  Call RememberPK("plantUsage", lngConc, "put")
  On Error Resume Next
    'close form
    DoCmd.Close acForm, "PlantUsage"
  On Error GoTo StoreFileErr
End If
  pltxa_ReturnPlantConcept_ID = lngPlantConceptInMem
End Function

Public Function pltxa_BrowseForPlantConcept() As Long
''function is enacted by user who wants to browse for a plant concept
    On Error GoTo StoreFileErr:
GoTo Past_err
StoreFileErr:
  msgBox "Error in browsing for plant concept!" & Chr(13) & Err.Description, vbCritical
  Exit Function
Past_err:
  ''make sure that anything currently stored is erased:
  pltxa_ReturnPlantConcept_ID 0, "put"
  ''open form to get new value
  DoCmd.OpenForm "PlantUsage", , , , , acDialog
  ''return result:
  pltxa_BrowseForPlantConcept = pltxa_ReturnPlantConcept_ID(-1, "get")
End Function

Public Function ChangePlantConc(strConcNm As String, lngConc As Long, Optional blnSkipNegative1 As Boolean) As Boolean
  ''function add plantName data to the VB_Reconcile table --> plantConcept_ID's
  '  Debug.Print strConc & " --> " & lngCocn
  If lngConc > 0 Or (lngConc = -1 And Not blnSkipNegative1) Then 'if it's 0 then the operation was cancelled
    ChangePlantConc = True
    addVBReconcile_Rec "plantName", strConcNm, "plantConcept", "plantConcept_ID", lngConc
    'on error resume next
    Forms!Z_USER_B_VB_view!PLANTCONCEPT_ID = lngConc
    Forms!Z_USER_B_VB_view.Refresh
    If lngConc = -1 Then
      'make sure plant is listed as new plant in Z_USER_B
     '@34 DoCmd.RunSQL "UPDATE Z_USER_B_SpecList SET NewPlantConcept = true WHERE plantCode = """ & strConcNm & """;"
    End If
  End If
End Function

Public Function addVBReconcile_Rec(strVariable As String, strVal As String, strTbl As String, _
          strFld As String, lngPK As Long, Optional strTxtVal As String)
''function takes values for Z_VB_Reconcile and adds them, deleting any old records with same values
''see if we are to add a text or numeric value
Dim blnText As Boolean
If strTxtVal <> "" Then
  blnText = True
Else
  blnText = False
End If
''get rst of values that already match, to delete
Dim rstRec As New ADODB.Recordset
rstRec.Open "SELECT * FROM Z_VB_Reconcile WHERE LoadVarName = " & SQLizeTxt(strVariable, "'") & " AND LoadVarValue = " _
     & SQLizeTxt(strVal, "'") & " AND VBTableNAme = " & SQLizeTxt(strTbl, "'") & " and VBFieldName = " & SQLizeTxt(strFld, "'") & ";" _
     , CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic, adCmdText
With rstRec
Do Until .EOF
  Dim inttemp As Integer
  inttemp = msgBox("You have already assigned this field value (" & strVal & ") to a VegBank value(" & IIf(blnText, !VBFieldTextVal, !VBFieldValue) & ")." & Chr(13) _
          & "Do you wish to delete the old value and replace it with a new one?", vbYesNoCancel)
  If inttemp = vbYes Then
    '''delete value
    .delete
  Else
    ''exit function, without adding the assignment
    msgBox "No assignment made, user cancelled."
    GoTo exitFcn
  End If
.MoveNext
Loop
''all previous values have been deleted, if there were any, ADD NEW REC With current value
.AddNew
!LoadVarName = strVariable
!LoadVarValue = strVal
!VBTableName = strTbl
!VBFieldName = strFld
If blnText Then
  !VBFieldTextVal = strTxtVal
Else
  !VBFieldValue = lngPK
End If
.Update
''record has been added, with current date as default value
End With
exitFcn:
End Function

Public Function pltxa_ReturnPlantName_ID(lngName As Long, GetPut As String) As Long
''function deals with browsing for plant concept (from Browse for file model):
    On Error GoTo StoreFileErr:
GoTo Past_err
StoreFileErr:
  msgBox "Error in storing plant name ID!" & Chr(13) & Err.Description, vbCritical
  Exit Function
Past_err:
Static lngPlantNameInMem As Long
If GetPut = "put" Then
  lngPlantNameInMem = lngName
  On Error Resume Next
    'close form
    DoCmd.Close acForm, "PlantName"
  On Error GoTo StoreFileErr
End If
  pltxa_ReturnPlantName_ID = lngPlantNameInMem
End Function

Public Function pltxa_BrowseForPlantName() As Long
''function is enacted by user who wants to browse for a plant name
    On Error GoTo StoreFileErr:
GoTo Past_err
StoreFileErr:
  msgBox "Error in browsing for plant name!" & Chr(13) & Err.Description, vbCritical
  Exit Function
Past_err:
  ''make sure that anything currently stored is erased:
  pltxa_ReturnPlantName_ID 0, "put"
  ''open form to get new value
  DoCmd.OpenForm "PlantName", , , , , acDialog
  ''return result:
  pltxa_BrowseForPlantName = pltxa_ReturnPlantName_ID(-1, "get")
End Function

Function testnfadfjdasfja()
  ChangePlantName "Goofer", 215201
End Function

Public Function ChangePlantName(strNm As String, lngPK As Long) As Boolean
  ''function changes plantNames to new plantName
  Dim strNewName As String
  strNewName = get_plantName_fromID(lngPK)
  If lngPK <> 0 And strNewName <> "" Then 'operation was cancelled
    Dim inttemp As Integer
    inttemp = msgBox("Are you sure you want to update the current plant name : " & strNm & Chr(13) _
         & "With the new plant name: " & strNewName, vbYesNoCancel)
    If inttemp = vbYes Then
        Dim rstChkPlCodes As New ADODB.Recordset
        rstChkPlCodes.Open "SELECT * FROM Z_USER_B_SpecList WHERE plantCode = " & SQLizeTxt(strNewName, "'") & " OR plantCode = " _
          & SQLizeTxt(strNm, "'") & ";", CurrentProject.Connection, adOpenStatic, adLockReadOnly, adCmdText
       '' Debug.Print "cnt:" & rstChkPlCodes.RecordCount
        If rstChkPlCodes.RecordCount = 2 Then
          'both the old and new names are present - will not succeed for SpecList
          msgBox "You already have the plantCode : """ & strNewName _
            & """ in your species list.  You cannot change the name : """ & strNm & """ to """ _
            & strNewName & """ as this would cause duplications!  First delete the former if you wish to replace it with the new name.", vbExclamation
          ChangePlantName = False
          Exit Function
        End If
        rstChkPlCodes.Close
        'run several SQL queries to update the various fields
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantNAme = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantNAme = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantcode = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantcode = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantShortNAme = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantShortNAme = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantCommonNAme = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantCommonNAme = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET OtherplantNAme = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE OtherplantNAme = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantSyn1 = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantSyn1 = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantSyn2 = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantSyn2 = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantSyn3 = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantSyn3 = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantSyn4 = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantSyn4 = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_B_SPEcList SET plantParent = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantParent = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_D_CoverData SET plantcode = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantcode = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_D2_StrataCover SET plantcode = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantcode = " & SQLizeTxt(strNm, "'") & ";"
        DoCmd.RunSQL "UPDATE Z_USER_E_StemData SET plantcode = " & SQLizeTxt(strNewName, "'") _
                              & " WHERE plantcode = " & SQLizeTxt(strNm, "'") & ";"
        'see if plantNAme already in Z_B
        If getvalFrmSQL("select plantNAme from Z_B_vb_lookupNms where plantName = " & SQLizeTxt(strNewName)) = strNewName Then
          'name already there, just delete current entry
          DoCmd.RunSQL "DELETE * FROM Z_B_VB_LookupNms WHERE plantName = " & SQLizeTxt(strNm, "'") & ";"
        Else
          'name not already in Z_B, update it
          DoCmd.RunSQL "UPDATE Z_B_VB_LookupNms SET plantName = " & SQLizeTxt(strNewName, "'") _
                              & " , plantName_ID = " & lngPK & " WHERE plantName = " & SQLizeTxt(strNm, "'") & ";"
        End If
        DoCmd.RunSQL "UPDATE Z_B_VB_lookupNms SET linkedThrough = " & SQLizeTxt(strNewName) & " WHERE linkedThrough=" & SQLizeTxt(strNm)
        'update lookups for old and new names
        populate_Z_B_LkNms True, strNewName
        populate_Z_B_LkNms True, strNm, True
        'on error resume next
             Forms!Z_USER_B_VB_view.Refresh
         ChangePlantName = True
    End If
  End If
End Function

Public Function PreviewPlants(strWhich As String)
  If strWhich = "name" Then
    DoCmd.OpenForm "Z_USER_B_NewNames"
  Else
    DoCmd.OpenForm "Z_USER_B_specList_new", , , "NewPlantConcept = true"
  End If
End Function

Public Function update_plantName_ConcUsg(Optional blnForceUpdate As Boolean)
  'updates the plantName field in plantConcept and plantUsage (denormalized)
  'increases size of data module by roughly 16MB for just USDA plants data
  DoCmd.RunSQL "UPDATE plantName INNER JOIN plantConcept ON plantName.PLANTNAME_ID = plantConcept.PLANTNAME_ID SET plantConcept.plantname = [plantName].[plantName] " & IIf(blnForceUpdate, ";", "WHERE plantConcept.plantNAme is null;"), False
  DoCmd.RunSQL "UPDATE plantName INNER JOIN plantUsage ON plantName.PLANTNAME_ID = plantUsage.PLANTNAME_ID SET plantUsage.plantname = [plantName].[plantName] " & IIf(blnForceUpdate, ";", "WHERE plantUsage.plantNAme is null;"), False
End Function

Public Function pltxa_FindInPlantLT(strName As String) As Boolean
  'function takes a string, here from Z_Lookup_B and looks to see if it's in Z_USER_B (for new concepts)
  Dim rstPlant As New ADODB.Recordset
  rstPlant.Open "SELECT * FROM Z_USER_B_SpecList WHERE plantCode = " & SQLizeTxt(strName, "'") & ";", CurrentProject.Connection _
     , adOpenForwardOnly, adLockReadOnly, adCmdText
  If rstPlant.EOF Then
    'can't find it
    pltxa_FindInPlantLT = False
  Else
    'did find the name in Z_USER_B, will be added from there
    pltxa_FindInPlantLT = True
  End If
End Function



Public Function getPartyID(Optional blnDontAsk As Boolean) As Long

'gets the current Party as specified in defaultMetaData2
  ''make sure vb_party_ID is filled in
DoCmd.RunSQL "UPDATE Default_metaData2 SET Default_metaData2.vbDefaultPartyID = getMetaData2Value(""DefaultParty"");"

Dim cnnLocal As Connection
Set cnnLocal = CurrentProject.Connection
Dim rstCurr As New ADODB.Recordset
Dim lngPartyID As Long
rstCurr.Open "Default_metaData2", cnnLocal, , adLockOptimistic, adCmdTable
'get Party_ID from Party that the user has identified his or herself as
With rstCurr
  If .EOF And .BOF Then ''should not happen : add new record
     .AddNew
     .Update
  End If
  If IsNull(!vbDefaultPartyID) Then
        getPartyID = -1
         If Not blnDontAsk Then ''make sure that party should be asked for:
           'does not exist in Party - must add
           If msgBox("You must specify who you are in the metadata form to add your plants." & Chr(13) _
             & "Would you like to do that now? PRESS YES" & Chr(13) & "press NO to cancel", vbYesNo) = vbYes Then
             DoCmd.OpenForm "Define_PartyRoles", , , , , acDialog
             'open new instance of fcn to get party
             getPartyID = getPartyID(blnDontAsk)
           Else
             Debug.Print "No plant Party"
           End If
           ''exit! - either we already have party, or user cancelled
           Exit Function
        End If  ''dont ask
  Else
    lngPartyID = !vbDefaultPartyID
  End If
  
End With
rstCurr.Close
  getPartyID = lngPartyID

End Function


Public Function getNameBeforeSpp(strPlant As String) As String
  'function takes a string plantName and strips everything before " sp. "
  If InStr(strPlant, " sp. #") > 0 Then
    getNameBeforeSpp = Trim(Left(strPlant, InStr(strPlant, " sp. #")))
  Else
    If Right(Trim(strPlant), 4) = " sp." Then
      getNameBeforeSpp = Left(Trim(strPlant), Len(Trim(strPlant)) - 4)
    Else
      getNameBeforeSpp = strPlant
    End If
  End If
End Function
